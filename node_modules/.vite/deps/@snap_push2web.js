import {
  BinaryReader,
  BinaryWriter,
  ConcatInjectable,
  Count,
  Injectable,
  Observable,
  ReplaySubject,
  Subject,
  TypedCustomEvent,
  TypedEventTarget,
  __publicField,
  __toESM,
  catchError,
  createExtension,
  externalMetricsSubjectFactory,
  getCameraKitUserAgent,
  lensSourcesFactory,
  map,
  of,
  require_browser_headers_umd,
  require_grpc_web_client_umd,
  share,
  switchMap,
  toPublicLens
} from "./chunk-ZXD7KNFK.js";

// node_modules/@snap/push2web/dist/Push2Web.js
var import_grpc_web2 = __toESM(require_grpc_web_client_umd());

// node_modules/@snap/push2web/dist/generated-api-client/camera_kit/v3/push_to_device.js
var import_grpc_web = __toESM(require_grpc_web_client_umd());
var import_browser_headers = __toESM(require_browser_headers_umd());

// node_modules/@snap/push2web/dist/generated-api-client/google/protobuf/any.js
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array(0) };
}
var Any = {
  encode(message, writer = new BinaryWriter()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.typeUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      typeUrl: isSet(object.typeUrl) ? globalThis.String(object.typeUrl) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.typeUrl !== "") {
      obj.typeUrl = message.typeUrl;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  create(base) {
    return Any.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAny();
    message.typeUrl = object.typeUrl ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  }
};
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isSet(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/push2web/dist/generated-api-client/camera_kit/v3/lens.js
var Lens_CameraFacing;
(function(Lens_CameraFacing2) {
  Lens_CameraFacing2["CAMERA_FACING_UNSET"] = "CAMERA_FACING_UNSET";
  Lens_CameraFacing2["CAMERA_FACING_FRONT"] = "CAMERA_FACING_FRONT";
  Lens_CameraFacing2["CAMERA_FACING_BACK"] = "CAMERA_FACING_BACK";
  Lens_CameraFacing2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(Lens_CameraFacing || (Lens_CameraFacing = {}));
function lens_CameraFacingFromJSON(object) {
  switch (object) {
    case 0:
    case "CAMERA_FACING_UNSET":
      return Lens_CameraFacing.CAMERA_FACING_UNSET;
    case 1:
    case "CAMERA_FACING_FRONT":
      return Lens_CameraFacing.CAMERA_FACING_FRONT;
    case 2:
    case "CAMERA_FACING_BACK":
      return Lens_CameraFacing.CAMERA_FACING_BACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Lens_CameraFacing.UNRECOGNIZED;
  }
}
function lens_CameraFacingToJSON(object) {
  switch (object) {
    case Lens_CameraFacing.CAMERA_FACING_UNSET:
      return "CAMERA_FACING_UNSET";
    case Lens_CameraFacing.CAMERA_FACING_FRONT:
      return "CAMERA_FACING_FRONT";
    case Lens_CameraFacing.CAMERA_FACING_BACK:
      return "CAMERA_FACING_BACK";
    case Lens_CameraFacing.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var LensAssetManifestItem_Type;
(function(LensAssetManifestItem_Type2) {
  LensAssetManifestItem_Type2["DEVICE_DEPENDENT_ASSET_UNSET"] = "DEVICE_DEPENDENT_ASSET_UNSET";
  LensAssetManifestItem_Type2["ASSET"] = "ASSET";
  LensAssetManifestItem_Type2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LensAssetManifestItem_Type || (LensAssetManifestItem_Type = {}));
function lensAssetManifestItem_TypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DEVICE_DEPENDENT_ASSET_UNSET":
      return LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET;
    case 1:
    case "ASSET":
      return LensAssetManifestItem_Type.ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LensAssetManifestItem_Type.UNRECOGNIZED;
  }
}
function lensAssetManifestItem_TypeToJSON(object) {
  switch (object) {
    case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:
      return "DEVICE_DEPENDENT_ASSET_UNSET";
    case LensAssetManifestItem_Type.ASSET:
      return "ASSET";
    case LensAssetManifestItem_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var LensAssetManifestItem_RequestTiming;
(function(LensAssetManifestItem_RequestTiming2) {
  LensAssetManifestItem_RequestTiming2["PRELOAD_UNSET"] = "PRELOAD_UNSET";
  LensAssetManifestItem_RequestTiming2["ON_DEMAND"] = "ON_DEMAND";
  LensAssetManifestItem_RequestTiming2["REQUIRED"] = "REQUIRED";
  LensAssetManifestItem_RequestTiming2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LensAssetManifestItem_RequestTiming || (LensAssetManifestItem_RequestTiming = {}));
function lensAssetManifestItem_RequestTimingFromJSON(object) {
  switch (object) {
    case 0:
    case "PRELOAD_UNSET":
      return LensAssetManifestItem_RequestTiming.PRELOAD_UNSET;
    case 1:
    case "ON_DEMAND":
      return LensAssetManifestItem_RequestTiming.ON_DEMAND;
    case 2:
    case "REQUIRED":
      return LensAssetManifestItem_RequestTiming.REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LensAssetManifestItem_RequestTiming.UNRECOGNIZED;
  }
}
function lensAssetManifestItem_RequestTimingToJSON(object) {
  switch (object) {
    case LensAssetManifestItem_RequestTiming.PRELOAD_UNSET:
      return "PRELOAD_UNSET";
    case LensAssetManifestItem_RequestTiming.ON_DEMAND:
      return "ON_DEMAND";
    case LensAssetManifestItem_RequestTiming.REQUIRED:
      return "REQUIRED";
    case LensAssetManifestItem_RequestTiming.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseLens() {
  return {
    id: "",
    name: "",
    vendorData: {},
    content: void 0,
    isThirdParty: false,
    cameraFacingPreference: Lens_CameraFacing.CAMERA_FACING_UNSET,
    featureMetadata: [],
    lensCreator: void 0,
    scannable: void 0
  };
}
var Lens = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          const entry3 = Lens_VendorDataEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.vendorData[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.content = Content.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.isThirdParty = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.cameraFacingPreference = lens_CameraFacingFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.featureMetadata.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.lensCreator = LensCreator.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.scannable = Scannable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet2(object.id) ? globalThis.String(object.id) : "",
      name: isSet2(object.name) ? globalThis.String(object.name) : "",
      vendorData: isObject(object.vendorData) ? Object.entries(object.vendorData).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      content: isSet2(object.content) ? Content.fromJSON(object.content) : void 0,
      isThirdParty: isSet2(object.isThirdParty) ? globalThis.Boolean(object.isThirdParty) : false,
      cameraFacingPreference: isSet2(object.cameraFacingPreference) ? lens_CameraFacingFromJSON(object.cameraFacingPreference) : Lens_CameraFacing.CAMERA_FACING_UNSET,
      featureMetadata: globalThis.Array.isArray(object == null ? void 0 : object.featureMetadata) ? object.featureMetadata.map((e) => Any.fromJSON(e)) : [],
      lensCreator: isSet2(object.lensCreator) ? LensCreator.fromJSON(object.lensCreator) : void 0,
      scannable: isSet2(object.scannable) ? Scannable.fromJSON(object.scannable) : void 0
    };
  },
  toJSON(message) {
    var _a;
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vendorData) {
      const entries = Object.entries(message.vendorData);
      if (entries.length > 0) {
        obj.vendorData = {};
        entries.forEach(([k, v]) => {
          obj.vendorData[k] = v;
        });
      }
    }
    if (message.content !== void 0) {
      obj.content = Content.toJSON(message.content);
    }
    if (message.isThirdParty !== false) {
      obj.isThirdParty = message.isThirdParty;
    }
    if (message.cameraFacingPreference !== Lens_CameraFacing.CAMERA_FACING_UNSET) {
      obj.cameraFacingPreference = lens_CameraFacingToJSON(message.cameraFacingPreference);
    }
    if ((_a = message.featureMetadata) == null ? void 0 : _a.length) {
      obj.featureMetadata = message.featureMetadata.map((e) => Any.toJSON(e));
    }
    if (message.lensCreator !== void 0) {
      obj.lensCreator = LensCreator.toJSON(message.lensCreator);
    }
    if (message.scannable !== void 0) {
      obj.scannable = Scannable.toJSON(message.scannable);
    }
    return obj;
  },
  create(base) {
    return Lens.fromPartial(base ?? {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLens();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.vendorData = Object.entries(object.vendorData ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.content = object.content !== void 0 && object.content !== null ? Content.fromPartial(object.content) : void 0;
    message.isThirdParty = object.isThirdParty ?? false;
    message.cameraFacingPreference = object.cameraFacingPreference ?? Lens_CameraFacing.CAMERA_FACING_UNSET;
    message.featureMetadata = ((_a = object.featureMetadata) == null ? void 0 : _a.map((e) => Any.fromPartial(e))) || [];
    message.lensCreator = object.lensCreator !== void 0 && object.lensCreator !== null ? LensCreator.fromPartial(object.lensCreator) : void 0;
    message.scannable = object.scannable !== void 0 && object.scannable !== null ? Scannable.fromPartial(object.scannable) : void 0;
    return message;
  }
};
function createBaseLens_VendorDataEntry() {
  return { key: "", value: "" };
}
var Lens_VendorDataEntry = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens_VendorDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet2(object.key) ? globalThis.String(object.key) : "",
      value: isSet2(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Lens_VendorDataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLens_VendorDataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseContent() {
  return {
    lnsUrl: "",
    lnsSha256: "",
    iconUrl: "",
    preview: void 0,
    assetManifest: [],
    defaultHintId: "",
    hintTranslations: {},
    lnsUrlBolt: "",
    iconUrlBolt: ""
  };
}
var Content = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lnsUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lnsSha256 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.iconUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.preview = Preview.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.assetManifest.push(LensAssetManifestItem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.defaultHintId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          const entry7 = Content_HintTranslationsEntry.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.hintTranslations[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.lnsUrlBolt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.iconUrlBolt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lnsUrl: isSet2(object.lnsUrl) ? globalThis.String(object.lnsUrl) : "",
      lnsSha256: isSet2(object.lnsSha256) ? globalThis.String(object.lnsSha256) : "",
      iconUrl: isSet2(object.iconUrl) ? globalThis.String(object.iconUrl) : "",
      preview: isSet2(object.preview) ? Preview.fromJSON(object.preview) : void 0,
      assetManifest: globalThis.Array.isArray(object == null ? void 0 : object.assetManifest) ? object.assetManifest.map((e) => LensAssetManifestItem.fromJSON(e)) : [],
      defaultHintId: isSet2(object.defaultHintId) ? globalThis.String(object.defaultHintId) : "",
      hintTranslations: isObject(object.hintTranslations) ? Object.entries(object.hintTranslations).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      lnsUrlBolt: isSet2(object.lnsUrlBolt) ? globalThis.String(object.lnsUrlBolt) : "",
      iconUrlBolt: isSet2(object.iconUrlBolt) ? globalThis.String(object.iconUrlBolt) : ""
    };
  },
  toJSON(message) {
    var _a;
    const obj = {};
    if (message.lnsUrl !== "") {
      obj.lnsUrl = message.lnsUrl;
    }
    if (message.lnsSha256 !== "") {
      obj.lnsSha256 = message.lnsSha256;
    }
    if (message.iconUrl !== "") {
      obj.iconUrl = message.iconUrl;
    }
    if (message.preview !== void 0) {
      obj.preview = Preview.toJSON(message.preview);
    }
    if ((_a = message.assetManifest) == null ? void 0 : _a.length) {
      obj.assetManifest = message.assetManifest.map((e) => LensAssetManifestItem.toJSON(e));
    }
    if (message.defaultHintId !== "") {
      obj.defaultHintId = message.defaultHintId;
    }
    if (message.hintTranslations) {
      const entries = Object.entries(message.hintTranslations);
      if (entries.length > 0) {
        obj.hintTranslations = {};
        entries.forEach(([k, v]) => {
          obj.hintTranslations[k] = v;
        });
      }
    }
    if (message.lnsUrlBolt !== "") {
      obj.lnsUrlBolt = message.lnsUrlBolt;
    }
    if (message.iconUrlBolt !== "") {
      obj.iconUrlBolt = message.iconUrlBolt;
    }
    return obj;
  },
  create(base) {
    return Content.fromPartial(base ?? {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseContent();
    message.lnsUrl = object.lnsUrl ?? "";
    message.lnsSha256 = object.lnsSha256 ?? "";
    message.iconUrl = object.iconUrl ?? "";
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.assetManifest = ((_a = object.assetManifest) == null ? void 0 : _a.map((e) => LensAssetManifestItem.fromPartial(e))) || [];
    message.defaultHintId = object.defaultHintId ?? "";
    message.hintTranslations = Object.entries(object.hintTranslations ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.lnsUrlBolt = object.lnsUrlBolt ?? "";
    message.iconUrlBolt = object.iconUrlBolt ?? "";
    return message;
  }
};
function createBaseContent_HintTranslationsEntry() {
  return { key: "", value: "" };
}
var Content_HintTranslationsEntry = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent_HintTranslationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet2(object.key) ? globalThis.String(object.key) : "",
      value: isSet2(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Content_HintTranslationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContent_HintTranslationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseLensAssetManifestItem() {
  return {
    type: LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET,
    id: "",
    requestTiming: LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
    assetUrl: "",
    assetChecksum: ""
  };
}
var LensAssetManifestItem = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensAssetManifestItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = lensAssetManifestItem_TypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.requestTiming = lensAssetManifestItem_RequestTimingFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.assetUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.assetChecksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet2(object.type) ? lensAssetManifestItem_TypeFromJSON(object.type) : LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET,
      id: isSet2(object.id) ? globalThis.String(object.id) : "",
      requestTiming: isSet2(object.requestTiming) ? lensAssetManifestItem_RequestTimingFromJSON(object.requestTiming) : LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
      assetUrl: isSet2(object.assetUrl) ? globalThis.String(object.assetUrl) : "",
      assetChecksum: isSet2(object.assetChecksum) ? globalThis.String(object.assetChecksum) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET) {
      obj.type = lensAssetManifestItem_TypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.requestTiming !== LensAssetManifestItem_RequestTiming.PRELOAD_UNSET) {
      obj.requestTiming = lensAssetManifestItem_RequestTimingToJSON(message.requestTiming);
    }
    if (message.assetUrl !== "") {
      obj.assetUrl = message.assetUrl;
    }
    if (message.assetChecksum !== "") {
      obj.assetChecksum = message.assetChecksum;
    }
    return obj;
  },
  create(base) {
    return LensAssetManifestItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLensAssetManifestItem();
    message.type = object.type ?? LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET;
    message.id = object.id ?? "";
    message.requestTiming = object.requestTiming ?? LensAssetManifestItem_RequestTiming.PRELOAD_UNSET;
    message.assetUrl = object.assetUrl ?? "";
    message.assetChecksum = object.assetChecksum ?? "";
    return message;
  }
};
function createBasePreview() {
  return { imageUrl: "", imageSequenceSize: 0, imageSequenceWebpUrlPattern: "" };
}
var Preview = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.imageSequenceSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.imageSequenceWebpUrlPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageUrl: isSet2(object.imageUrl) ? globalThis.String(object.imageUrl) : "",
      imageSequenceSize: isSet2(object.imageSequenceSize) ? globalThis.Number(object.imageSequenceSize) : 0,
      imageSequenceWebpUrlPattern: isSet2(object.imageSequenceWebpUrlPattern) ? globalThis.String(object.imageSequenceWebpUrlPattern) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    if (message.imageSequenceSize !== 0) {
      obj.imageSequenceSize = Math.round(message.imageSequenceSize);
    }
    if (message.imageSequenceWebpUrlPattern !== "") {
      obj.imageSequenceWebpUrlPattern = message.imageSequenceWebpUrlPattern;
    }
    return obj;
  },
  create(base) {
    return Preview.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePreview();
    message.imageUrl = object.imageUrl ?? "";
    message.imageSequenceSize = object.imageSequenceSize ?? 0;
    message.imageSequenceWebpUrlPattern = object.imageSequenceWebpUrlPattern ?? "";
    return message;
  }
};
function createBaseLensCreator() {
  return { displayName: "" };
}
var LensCreator = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { displayName: isSet2(object.displayName) ? globalThis.String(object.displayName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },
  create(base) {
    return LensCreator.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseLensCreator();
    message.displayName = object.displayName ?? "";
    return message;
  }
};
function createBaseScannable() {
  return { snapcodeImageUrl: "", snapcodeDeeplink: "" };
}
var Scannable = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScannable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapcodeImageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.snapcodeDeeplink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      snapcodeImageUrl: isSet2(object.snapcodeImageUrl) ? globalThis.String(object.snapcodeImageUrl) : "",
      snapcodeDeeplink: isSet2(object.snapcodeDeeplink) ? globalThis.String(object.snapcodeDeeplink) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapcodeImageUrl !== "") {
      obj.snapcodeImageUrl = message.snapcodeImageUrl;
    }
    if (message.snapcodeDeeplink !== "") {
      obj.snapcodeDeeplink = message.snapcodeDeeplink;
    }
    return obj;
  },
  create(base) {
    return Scannable.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseScannable();
    message.snapcodeImageUrl = object.snapcodeImageUrl ?? "";
    message.snapcodeDeeplink = object.snapcodeDeeplink ?? "";
    return message;
  }
};
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet2(value) {
  return value !== null && value !== void 0;
}

// node_modules/@snap/push2web/dist/generated-api-client/camera_kit/v3/push_to_device.js
var PushLensSubscriptionResponse_ExcludedLens_Code;
(function(PushLensSubscriptionResponse_ExcludedLens_Code2) {
  PushLensSubscriptionResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  PushLensSubscriptionResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  PushLensSubscriptionResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  PushLensSubscriptionResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  PushLensSubscriptionResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  PushLensSubscriptionResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  PushLensSubscriptionResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(PushLensSubscriptionResponse_ExcludedLens_Code || (PushLensSubscriptionResponse_ExcludedLens_Code = {}));
var ListenLensPushResponse_ExcludedLens_Code;
(function(ListenLensPushResponse_ExcludedLens_Code2) {
  ListenLensPushResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  ListenLensPushResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  ListenLensPushResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  ListenLensPushResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  ListenLensPushResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  ListenLensPushResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  ListenLensPushResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ListenLensPushResponse_ExcludedLens_Code || (ListenLensPushResponse_ExcludedLens_Code = {}));
function listenLensPushResponse_ExcludedLens_CodeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSET":
      return ListenLensPushResponse_ExcludedLens_Code.UNSET;
    case 1:
    case "UNKNOWN":
      return ListenLensPushResponse_ExcludedLens_Code.UNKNOWN;
    case 2:
    case "NOT_FOUND":
      return ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND;
    case 3:
    case "INCOMPATIBLE_LENS_CORE_VERSION":
      return ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
    case 4:
    case "ARCHIVED_OR_INVISIBLE":
      return ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
    case 5:
    case "CONTAINS_MUSIC":
      return ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED;
  }
}
function listenLensPushResponse_ExcludedLens_CodeToJSON(object) {
  switch (object) {
    case ListenLensPushResponse_ExcludedLens_Code.UNSET:
      return "UNSET";
    case ListenLensPushResponse_ExcludedLens_Code.UNKNOWN:
      return "UNKNOWN";
    case ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND:
      return "NOT_FOUND";
    case ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
      return "INCOMPATIBLE_LENS_CORE_VERSION";
    case ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
      return "ARCHIVED_OR_INVISIBLE";
    case ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC:
      return "CONTAINS_MUSIC";
    case ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseListenLensPushRequest() {
  return { extensionRequestContext: new Uint8Array(0), heartbeat: 0 };
}
var ListenLensPushRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.extensionRequestContext.length !== 0) {
      writer.uint32(18).bytes(message.extensionRequestContext);
    }
    if (message.heartbeat !== 0) {
      writer.uint32(24).int32(message.heartbeat);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListenLensPushRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extensionRequestContext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.heartbeat = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      extensionRequestContext: isSet3(object.extensionRequestContext) ? bytesFromBase642(object.extensionRequestContext) : new Uint8Array(0),
      heartbeat: isSet3(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.extensionRequestContext.length !== 0) {
      obj.extensionRequestContext = base64FromBytes2(message.extensionRequestContext);
    }
    if (message.heartbeat !== 0) {
      obj.heartbeat = Math.round(message.heartbeat);
    }
    return obj;
  },
  create(base) {
    return ListenLensPushRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListenLensPushRequest();
    message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array(0);
    message.heartbeat = object.heartbeat ?? 0;
    return message;
  }
};
function createBaseListenLensPushResponse() {
  return { excludedLens: void 0, heartbeat: 0, lenses: {} };
}
var ListenLensPushResponse = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListenLensPushResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.excludedLens = ListenLensPushResponse_ExcludedLens.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.heartbeat = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          const entry4 = ListenLensPushResponse_LensesEntry.decode(reader, reader.uint32());
          if (entry4.value !== void 0) {
            message.lenses[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      excludedLens: isSet3(object.excludedLens) ? ListenLensPushResponse_ExcludedLens.fromJSON(object.excludedLens) : void 0,
      heartbeat: isSet3(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
      lenses: isObject2(object.lenses) ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
        acc[key] = bytesFromBase642(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.excludedLens !== void 0) {
      obj.excludedLens = ListenLensPushResponse_ExcludedLens.toJSON(message.excludedLens);
    }
    if (message.heartbeat !== 0) {
      obj.heartbeat = Math.round(message.heartbeat);
    }
    if (message.lenses) {
      const entries = Object.entries(message.lenses);
      if (entries.length > 0) {
        obj.lenses = {};
        entries.forEach(([k, v]) => {
          obj.lenses[k] = base64FromBytes2(v);
        });
      }
    }
    return obj;
  },
  create(base) {
    return ListenLensPushResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListenLensPushResponse();
    message.excludedLens = object.excludedLens !== void 0 && object.excludedLens !== null ? ListenLensPushResponse_ExcludedLens.fromPartial(object.excludedLens) : void 0;
    message.heartbeat = object.heartbeat ?? 0;
    message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseListenLensPushResponse_LensesEntry() {
  return { key: "", value: new Uint8Array(0) };
}
var ListenLensPushResponse_LensesEntry = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListenLensPushResponse_LensesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? bytesFromBase642(object.value) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes2(message.value);
    }
    return obj;
  },
  create(base) {
    return ListenLensPushResponse_LensesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListenLensPushResponse_LensesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  }
};
function createBaseListenLensPushResponse_ExcludedLens() {
  return { lensId: "0", code: ListenLensPushResponse_ExcludedLens_Code.UNSET };
}
var ListenLensPushResponse_ExcludedLens = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListenLensPushResponse_ExcludedLens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.lensId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.code = listenLensPushResponse_ExcludedLens_CodeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lensId: isSet3(object.lensId) ? globalThis.String(object.lensId) : "0",
      code: isSet3(object.code) ? listenLensPushResponse_ExcludedLens_CodeFromJSON(object.code) : ListenLensPushResponse_ExcludedLens_Code.UNSET
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.lensId !== "0") {
      obj.lensId = message.lensId;
    }
    if (message.code !== ListenLensPushResponse_ExcludedLens_Code.UNSET) {
      obj.code = listenLensPushResponse_ExcludedLens_CodeToJSON(message.code);
    }
    return obj;
  },
  create(base) {
    return ListenLensPushResponse_ExcludedLens.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListenLensPushResponse_ExcludedLens();
    message.lensId = object.lensId ?? "0";
    message.code = object.code ?? ListenLensPushResponse_ExcludedLens_Code.UNSET;
    return message;
  }
};
var PushToDeviceClientImpl = class {
  constructor(rpc) {
    __publicField(this, "rpc");
    this.rpc = rpc;
    this.PushLensSubscription = this.PushLensSubscription.bind(this);
    this.ListenLensPush = this.ListenLensPush.bind(this);
  }
  PushLensSubscription(request, metadata) {
    throw new Error("ts-proto does not yet support client streaming!");
  }
  ListenLensPush(request, metadata) {
    return this.rpc.invoke(PushToDeviceListenLensPushDesc, ListenLensPushRequest.fromPartial(request), metadata);
  }
};
var PushToDeviceDesc = { serviceName: "com.snap.camerakit.v3.PushToDevice" };
var PushToDeviceListenLensPushDesc = {
  methodName: "ListenLensPush",
  service: PushToDeviceDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return ListenLensPushRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = ListenLensPushResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        }
      };
    }
  }
};
var GrpcWebImpl = class {
  constructor(host, options) {
    __publicField(this, "host");
    __publicField(this, "options");
    this.host = host;
    this.options = options;
  }
  unary(methodDesc, _request, metadata) {
    var _a;
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata ? new import_browser_headers.BrowserHeaders({ ...(_a = this.options) == null ? void 0 : _a.metadata.headersMap, ...metadata == null ? void 0 : metadata.headersMap }) : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      import_grpc_web.grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...this.options.transport !== void 0 ? { transport: this.options.transport } : {},
        debug: this.options.debug ?? false,
        onEnd: function(response) {
          if (response.status === import_grpc_web.grpc.Code.OK) {
            resolve(response.message.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        }
      });
    });
  }
  invoke(methodDesc, _request, metadata) {
    var _a;
    const upStreamCodes = this.options.upStreamRetryCodes ?? [];
    const DEFAULT_TIMEOUT_TIME = 3e3;
    const request = { ..._request, ...methodDesc.requestType };
    const transport = this.options.streamingTransport ?? this.options.transport;
    const maybeCombinedMetadata = metadata && this.options.metadata ? new import_browser_headers.BrowserHeaders({ ...(_a = this.options) == null ? void 0 : _a.metadata.headersMap, ...metadata == null ? void 0 : metadata.headersMap }) : metadata ?? this.options.metadata;
    return new Observable((observer) => {
      const upStream = () => {
        const client = import_grpc_web.grpc.invoke(methodDesc, {
          host: this.host,
          request,
          ...transport !== void 0 ? { transport } : {},
          metadata: maybeCombinedMetadata ?? {},
          debug: this.options.debug ?? false,
          onMessage: (next) => observer.next(next),
          onEnd: (code, message, trailers) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message);
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          }
        });
        observer.add(() => client.close());
      };
      upStream();
    }).pipe(share());
  }
};
function bytesFromBase642(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes2(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet3(value) {
  return value !== null && value !== void 0;
}
var GrpcWebError = class extends globalThis.Error {
  constructor(message, code, metadata) {
    super(message);
    __publicField(this, "code");
    __publicField(this, "metadata");
    this.code = code;
    this.metadata = metadata;
  }
};

// node_modules/@snap/push2web/dist/generated-api-client/camera_kit/v3/export.js
var ExportLensesByIdRequest_Context_Extension_Name;
(function(ExportLensesByIdRequest_Context_Extension_Name2) {
  ExportLensesByIdRequest_Context_Extension_Name2["UNSET"] = "UNSET";
  ExportLensesByIdRequest_Context_Extension_Name2["SHOP_KIT"] = "SHOP_KIT";
  ExportLensesByIdRequest_Context_Extension_Name2["LENS_WEB_BUILDER"] = "LENS_WEB_BUILDER";
  ExportLensesByIdRequest_Context_Extension_Name2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdRequest_Context_Extension_Name || (ExportLensesByIdRequest_Context_Extension_Name = {}));
var ExportLensesByIdResponse_ExcludedLens_Code;
(function(ExportLensesByIdResponse_ExcludedLens_Code2) {
  ExportLensesByIdResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  ExportLensesByIdResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  ExportLensesByIdResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  ExportLensesByIdResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  ExportLensesByIdResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdResponse_ExcludedLens_Code || (ExportLensesByIdResponse_ExcludedLens_Code = {}));
function createBaseEnvelope() {
  return { lenses: [] };
}
var Envelope = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { lenses: globalThis.Array.isArray(object == null ? void 0 : object.lenses) ? object.lenses.map((e) => Lens.fromJSON(e)) : [] };
  },
  toJSON(message) {
    var _a;
    const obj = {};
    if ((_a = message.lenses) == null ? void 0 : _a.length) {
      obj.lenses = message.lenses.map((e) => Lens.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEnvelope();
    message.lenses = ((_a = object.lenses) == null ? void 0 : _a.map((e) => Lens.fromPartial(e))) || [];
    return message;
  }
};

// node_modules/@snap/push2web/dist/generated-api-client/core/snap_status_code.js
var Code;
(function(Code2) {
  Code2["OK"] = "OK";
  Code2["CANCELLED"] = "CANCELLED";
  Code2["UNKNOWN"] = "UNKNOWN";
  Code2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  Code2["DEADLINE_EXCEEDED"] = "DEADLINE_EXCEEDED";
  Code2["NOT_FOUND"] = "NOT_FOUND";
  Code2["ALREADY_EXISTS"] = "ALREADY_EXISTS";
  Code2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Code2["UNAUTHENTICATED"] = "UNAUTHENTICATED";
  Code2["RESOURCE_EXHAUSTED"] = "RESOURCE_EXHAUSTED";
  Code2["FAILED_PRECONDITION"] = "FAILED_PRECONDITION";
  Code2["ABORTED"] = "ABORTED";
  Code2["OUT_OF_RANGE"] = "OUT_OF_RANGE";
  Code2["UNIMPLEMENTED"] = "UNIMPLEMENTED";
  Code2["INTERNAL"] = "INTERNAL";
  Code2["UNAVAILABLE"] = "UNAVAILABLE";
  Code2["DATA_LOSS"] = "DATA_LOSS";
  Code2["NOT_MODIFIED"] = "NOT_MODIFIED";
  Code2["DECRYPTION_FAILED"] = "DECRYPTION_FAILED";
  Code2["INVALID_MEDIA"] = "INVALID_MEDIA";
  Code2["IN_PROGRESS"] = "IN_PROGRESS";
  Code2["CONTENT_TOO_LARGE"] = "CONTENT_TOO_LARGE";
  Code2["URL_PROTOCOL_NOT_SUPPORTED"] = "URL_PROTOCOL_NOT_SUPPORTED";
  Code2["URL_CONTENT_TYPE_NOT_WHITELISTED"] = "URL_CONTENT_TYPE_NOT_WHITELISTED";
  Code2["URL_DOWNLOAD_FAILURE"] = "URL_DOWNLOAD_FAILURE";
  Code2["CLOUD_STORAGE_FAILURE"] = "CLOUD_STORAGE_FAILURE";
  Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(Code || (Code = {}));
function codeFromJSON(object) {
  switch (object) {
    case 0:
    case "OK":
      return Code.OK;
    case 1:
    case "CANCELLED":
      return Code.CANCELLED;
    case 2:
    case "UNKNOWN":
      return Code.UNKNOWN;
    case 3:
    case "INVALID_ARGUMENT":
      return Code.INVALID_ARGUMENT;
    case 4:
    case "DEADLINE_EXCEEDED":
      return Code.DEADLINE_EXCEEDED;
    case 5:
    case "NOT_FOUND":
      return Code.NOT_FOUND;
    case 6:
    case "ALREADY_EXISTS":
      return Code.ALREADY_EXISTS;
    case 7:
    case "PERMISSION_DENIED":
      return Code.PERMISSION_DENIED;
    case 16:
    case "UNAUTHENTICATED":
      return Code.UNAUTHENTICATED;
    case 8:
    case "RESOURCE_EXHAUSTED":
      return Code.RESOURCE_EXHAUSTED;
    case 9:
    case "FAILED_PRECONDITION":
      return Code.FAILED_PRECONDITION;
    case 10:
    case "ABORTED":
      return Code.ABORTED;
    case 11:
    case "OUT_OF_RANGE":
      return Code.OUT_OF_RANGE;
    case 12:
    case "UNIMPLEMENTED":
      return Code.UNIMPLEMENTED;
    case 13:
    case "INTERNAL":
      return Code.INTERNAL;
    case 14:
    case "UNAVAILABLE":
      return Code.UNAVAILABLE;
    case 15:
    case "DATA_LOSS":
      return Code.DATA_LOSS;
    case 100:
    case "NOT_MODIFIED":
      return Code.NOT_MODIFIED;
    case 101:
    case "DECRYPTION_FAILED":
      return Code.DECRYPTION_FAILED;
    case 102:
    case "INVALID_MEDIA":
      return Code.INVALID_MEDIA;
    case 200:
    case "IN_PROGRESS":
      return Code.IN_PROGRESS;
    case 201:
    case "CONTENT_TOO_LARGE":
      return Code.CONTENT_TOO_LARGE;
    case 202:
    case "URL_PROTOCOL_NOT_SUPPORTED":
      return Code.URL_PROTOCOL_NOT_SUPPORTED;
    case 203:
    case "URL_CONTENT_TYPE_NOT_WHITELISTED":
      return Code.URL_CONTENT_TYPE_NOT_WHITELISTED;
    case 204:
    case "URL_DOWNLOAD_FAILURE":
      return Code.URL_DOWNLOAD_FAILURE;
    case 205:
    case "CLOUD_STORAGE_FAILURE":
      return Code.CLOUD_STORAGE_FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Code.UNRECOGNIZED;
  }
}

// node_modules/@snap/push2web/dist/Push2WebSDKExtension.js
function assertUnreachable(_) {
  throw new Error("Reached unreachable code at runtime.");
}
var Push2WebSDKExtension = class {
  constructor() {
    __publicField(this, "extension");
    __publicField(this, "groupId", "PUSH_2_WEB_GROUP_ID");
    __publicField(this, "lastPushedEnvelope");
    __publicField(this, "metricsSubject", new Subject());
    const push2WebLensSource = {
      isGroupOwner: (groupId) => groupId === this.groupId,
      loadLens: async () => {
        if (this.lastPushedEnvelope != void 0) {
          return this.lastPushedEnvelope;
        }
        throw new Error("No pushed lens found.");
      },
      loadLensGroup: async () => {
        if (this.lastPushedEnvelope != void 0) {
          return this.lastPushedEnvelope;
        }
        return new ArrayBuffer(0);
      }
    };
    this.extension = createExtension().provides(ConcatInjectable(lensSourcesFactory.token, () => push2WebLensSource)).provides(Injectable(externalMetricsSubjectFactory.token, () => this.metricsSubject));
  }
  updateEnvelope(newEnvelope) {
    this.lastPushedEnvelope = newEnvelope;
  }
  reportEvent(events) {
    const { type } = events;
    switch (type) {
      case "error": {
        const dimensions = {};
        if (events.detail.name === "CommunicationError") {
          dimensions["type"] = "subscription";
          dimensions["cause"] = events.detail.grpcStatus;
        } else if (events.detail.name === "LensExcludedError") {
          dimensions["type"] = "lens_excluded";
          dimensions["cause"] = events.detail.cause.message;
        }
        this.metricsSubject.next(Count.count("push2web_error", 1, dimensions));
        break;
      }
      case "lensReceived": {
        this.metricsSubject.next(Count.count("push2web_received", 1));
        break;
      }
      case "subscriptionChanged":
        break;
      default: {
        assertUnreachable(type);
      }
    }
  }
};

// node_modules/@snap/push2web/dist/Push2Web.js
var Push2Web = class {
  /**
   * Create new instance of Push2Web object,
   * it can be used to start listening for the events,
   * subscribe or unsubscribe for notifications from Lens Studio.
   * Also provides the extension object for the @snap/camera-kit package.
   */
  constructor() {
    /**
     * Use this property to subscribe for the different types of events that can occur during push 2 web execution.
     *
     * Subscribe to `error` event to be aware if something has happened during the lens push,
     * with network communication or any other type of error,
     * event object also contains detailed explanation of the cause.
     *
     * Use `subscriptionChanged` event to be aware when subscription state is changed.
     *
     * Use `lensReceived` event to be aware when new lens is received from Lens Studio,
     * also you can get the additional details about the pushed lens.
     *
     * @example
     *```ts
     *push2web.events.addEventListener('error', ({ detail }) => {
     *   if (detail.name === 'LensExcludedError') {
     *     console.log(`Lens is excluded from the push, by the following reason: ${detail.reason}.`)
     *   }
     *})
     *```
     */
    __publicField(this, "events", new TypedEventTarget());
    __publicField(this, "push2WebExtension", new Push2WebSDKExtension());
    __publicField(this, "pushedLenses");
    __publicField(this, "accessToken", new ReplaySubject(1));
    __publicField(this, "subscription");
    this.pushedLenses = this.accessToken.pipe(switchMap((accessToken) => {
      const metadata = new import_grpc_web2.grpc.Metadata();
      metadata.append("Authorization", `Bearer ${accessToken}`);
      metadata.append("x-snap-client-user-agent", getCameraKitUserAgent());
      const grpcWeb = new GrpcWebImpl("https://api-kit.snapchat.com", {
        metadata,
        // We want to retry the request if any of the following issues occur (including timeout).
        // This allows us to long-poll the service.
        upStreamRetryCodes: [
          import_grpc_web2.grpc.Code.Unknown,
          import_grpc_web2.grpc.Code.DeadlineExceeded,
          import_grpc_web2.grpc.Code.ResourceExhausted,
          import_grpc_web2.grpc.Code.FailedPrecondition,
          import_grpc_web2.grpc.Code.Aborted,
          import_grpc_web2.grpc.Code.Internal,
          import_grpc_web2.grpc.Code.Unavailable,
          import_grpc_web2.grpc.Code.DataLoss
        ]
      });
      const push2WebClient = new PushToDeviceClientImpl(grpcWeb);
      return push2WebClient.ListenLensPush(ListenLensPushRequest.fromPartial({})).pipe(map(({ lenses, excludedLens }) => {
        if (excludedLens) {
          return new TypedCustomEvent("error", {
            name: "LensExcludedError",
            cause: new Error(listenLensPushResponse_ExcludedLens_CodeFromJSON(excludedLens.code)),
            lensId: excludedLens.lensId,
            reason: listenLensPushResponse_ExcludedLens_CodeFromJSON(excludedLens.code)
          });
        }
        const envelope = Object.values(lenses)[0];
        this.push2WebExtension.updateEnvelope(envelope);
        const [lens] = Envelope.decode(envelope).lenses;
        const groupId = this.push2WebExtension.groupId;
        return new TypedCustomEvent("lensReceived", toPublicLens({ ...lens, groupId }));
      }), catchError((error) => {
        const grpcError = /Error ([\d]{1,3})/.exec(error.message);
        if (grpcError) {
          this.events.dispatchEvent(new TypedCustomEvent("subscriptionChanged", State.Unsubscribed));
          const grpcCode = parseInt(grpcError[1]);
          return of(new TypedCustomEvent("error", {
            name: "CommunicationError",
            cause: error,
            grpcStatus: codeFromJSON(grpcCode),
            grpcCode
          }));
        }
        return of(new TypedCustomEvent("error", { name: "GenericError", cause: error }));
      }));
    }));
  }
  /**
   * The extension object must be passed to the Camera Kit object during its bootstrap process.
   * This is a requirement for the proper functioning of push to web functionality.
   *
   * @example
   * ```ts
   *import { bootstrapCameraKit } from "@snap/camera-kit";
   *
   *const push2web = new Push2Web();
   *const extensions = (container) => container.provides(push2Web.extension);
   *
   *const cameraKit = await bootstrapCameraKit({ apiToken: "token from developer portal" }, extensions);
   *const cameraKitSession = await cameraKit.createSession();
   * ```
   */
  get extension() {
    return this.push2WebExtension.extension;
  }
  /**
   * Initiate subscription for the events from Lens Studio.
   *
   * @param accessToken - After user will be logged in to the web page,
   * using Snapchat account, you can get access token from Login Kit.
   * @param cameraKitSession - Instance of CameraKitSession object form @snap/camera-kit package.
   * @param repository - Instance of LensRepository object from @snap/camera-kit package.
   * @returns @SubscriptionInstance
   */
  subscribe(accessToken, cameraKitSession, repository) {
    var _a;
    (_a = this.subscription) == null ? void 0 : _a.unsubscribe();
    this.accessToken.next(accessToken);
    this.subscription = this.pushedLenses.subscribe({
      next: async (event) => {
        this.events.dispatchEvent(event);
        if (event.type === "lensReceived") {
          try {
            const lens = await repository.loadLens(event.detail.id, this.push2WebExtension.groupId);
            await cameraKitSession.removeLens();
            await cameraKitSession.applyLens(lens);
          } catch (error) {
            this.events.dispatchEvent(new TypedCustomEvent("error", {
              name: "GenericError",
              cause: error
            }));
          }
        }
        this.push2WebExtension.reportEvent(event);
      }
    });
    this.events.dispatchEvent(new TypedCustomEvent("subscriptionChanged", State.Subscribed));
    return {
      unsubscribe: async () => {
        if (this.subscription) {
          this.subscription.unsubscribe();
          this.subscription = void 0;
          this.events.dispatchEvent(new TypedCustomEvent("subscriptionChanged", State.Unsubscribed));
        }
      },
      updateAccessToken: (accessToken2) => {
        this.accessToken.next(accessToken2);
      }
    };
  }
};
var State;
(function(State2) {
  State2["Subscribed"] = "Subscribed";
  State2["Unsubscribed"] = "Unsubscribed";
})(State || (State = {}));
export {
  Code,
  ListenLensPushResponse_ExcludedLens_Code,
  Push2Web,
  State
};
//# sourceMappingURL=@snap_push2web.js.map
