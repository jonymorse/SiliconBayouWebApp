import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
import { Lens } from "./lens";
export const protobufPackage = "com.snap.camerakit.v3";
export var PushLensSubscriptionResponse_ExcludedLens_Code;
(function (PushLensSubscriptionResponse_ExcludedLens_Code) {
    PushLensSubscriptionResponse_ExcludedLens_Code["UNSET"] = "UNSET";
    PushLensSubscriptionResponse_ExcludedLens_Code["UNKNOWN"] = "UNKNOWN";
    PushLensSubscriptionResponse_ExcludedLens_Code["NOT_FOUND"] = "NOT_FOUND";
    PushLensSubscriptionResponse_ExcludedLens_Code["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
    PushLensSubscriptionResponse_ExcludedLens_Code["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
    PushLensSubscriptionResponse_ExcludedLens_Code["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
    PushLensSubscriptionResponse_ExcludedLens_Code["UNRECOGNIZED"] = "UNRECOGNIZED";
})(PushLensSubscriptionResponse_ExcludedLens_Code || (PushLensSubscriptionResponse_ExcludedLens_Code = {}));
export function pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNSET;
        case 1:
        case "UNKNOWN":
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN;
        case 2:
        case "NOT_FOUND":
            return PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND;
        case 3:
        case "INCOMPATIBLE_LENS_CORE_VERSION":
            return PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
        case 4:
        case "ARCHIVED_OR_INVISIBLE":
            return PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
        case 5:
        case "CONTAINS_MUSIC":
            return PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNRECOGNIZED;
    }
}
export function pushLensSubscriptionResponse_ExcludedLens_CodeToJSON(object) {
    switch (object) {
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNSET:
            return "UNSET";
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN:
            return "UNKNOWN";
        case PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND:
            return "NOT_FOUND";
        case PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return "INCOMPATIBLE_LENS_CORE_VERSION";
        case PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return "ARCHIVED_OR_INVISIBLE";
        case PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return "CONTAINS_MUSIC";
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export function pushLensSubscriptionResponse_ExcludedLens_CodeToNumber(object) {
    switch (object) {
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNSET:
            return 0;
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN:
            return 1;
        case PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND:
            return 2;
        case PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return 3;
        case PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return 4;
        case PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return 5;
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNRECOGNIZED:
        default:
            return -1;
    }
}
export var ListenLensPushResponse_ExcludedLens_Code;
(function (ListenLensPushResponse_ExcludedLens_Code) {
    ListenLensPushResponse_ExcludedLens_Code["UNSET"] = "UNSET";
    ListenLensPushResponse_ExcludedLens_Code["UNKNOWN"] = "UNKNOWN";
    ListenLensPushResponse_ExcludedLens_Code["NOT_FOUND"] = "NOT_FOUND";
    ListenLensPushResponse_ExcludedLens_Code["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
    ListenLensPushResponse_ExcludedLens_Code["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
    ListenLensPushResponse_ExcludedLens_Code["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
    ListenLensPushResponse_ExcludedLens_Code["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ListenLensPushResponse_ExcludedLens_Code || (ListenLensPushResponse_ExcludedLens_Code = {}));
export function listenLensPushResponse_ExcludedLens_CodeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return ListenLensPushResponse_ExcludedLens_Code.UNSET;
        case 1:
        case "UNKNOWN":
            return ListenLensPushResponse_ExcludedLens_Code.UNKNOWN;
        case 2:
        case "NOT_FOUND":
            return ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND;
        case 3:
        case "INCOMPATIBLE_LENS_CORE_VERSION":
            return ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
        case 4:
        case "ARCHIVED_OR_INVISIBLE":
            return ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
        case 5:
        case "CONTAINS_MUSIC":
            return ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED;
    }
}
export function listenLensPushResponse_ExcludedLens_CodeToJSON(object) {
    switch (object) {
        case ListenLensPushResponse_ExcludedLens_Code.UNSET:
            return "UNSET";
        case ListenLensPushResponse_ExcludedLens_Code.UNKNOWN:
            return "UNKNOWN";
        case ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND:
            return "NOT_FOUND";
        case ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return "INCOMPATIBLE_LENS_CORE_VERSION";
        case ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return "ARCHIVED_OR_INVISIBLE";
        case ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return "CONTAINS_MUSIC";
        case ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export function listenLensPushResponse_ExcludedLens_CodeToNumber(object) {
    switch (object) {
        case ListenLensPushResponse_ExcludedLens_Code.UNSET:
            return 0;
        case ListenLensPushResponse_ExcludedLens_Code.UNKNOWN:
            return 1;
        case ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND:
            return 2;
        case ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return 3;
        case ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return 4;
        case ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return 5;
        case ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED:
        default:
            return -1;
    }
}
function createBasePushLensSubscriptionRequest() {
    return { accountId: "", extensionRequestContext: new Uint8Array(0), heartbeat: 0 };
}
export const PushLensSubscriptionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.accountId !== "") {
            writer.uint32(10).string(message.accountId);
        }
        if (message.extensionRequestContext.length !== 0) {
            writer.uint32(18).bytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            writer.uint32(24).int32(message.heartbeat);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.accountId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.extensionRequestContext = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.heartbeat = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
            extensionRequestContext: isSet(object.extensionRequestContext)
                ? bytesFromBase64(object.extensionRequestContext)
                : new Uint8Array(0),
            heartbeat: isSet(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.accountId !== "") {
            obj.accountId = message.accountId;
        }
        if (message.extensionRequestContext.length !== 0) {
            obj.extensionRequestContext = base64FromBytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            obj.heartbeat = Math.round(message.heartbeat);
        }
        return obj;
    },
    create(base) {
        return PushLensSubscriptionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionRequest();
        message.accountId = object.accountId ?? "";
        message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array(0);
        message.heartbeat = object.heartbeat ?? 0;
        return message;
    },
};
function createBasePushLensSubscriptionResponse() {
    return { lens: undefined, excludedLens: undefined, heartbeat: 0, lenses: {} };
}
export const PushLensSubscriptionResponse = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.lens = Lens.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.excludedLens = PushLensSubscriptionResponse_ExcludedLens.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.heartbeat = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = PushLensSubscriptionResponse_LensesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.lenses[entry4.key] = entry4.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            lens: isSet(object.lens) ? Lens.fromJSON(object.lens) : undefined,
            excludedLens: isSet(object.excludedLens)
                ? PushLensSubscriptionResponse_ExcludedLens.fromJSON(object.excludedLens)
                : undefined,
            heartbeat: isSet(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
            lenses: isObject(object.lenses)
                ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.lens !== undefined) {
            obj.lens = Lens.toJSON(message.lens);
        }
        if (message.excludedLens !== undefined) {
            obj.excludedLens = PushLensSubscriptionResponse_ExcludedLens.toJSON(message.excludedLens);
        }
        if (message.heartbeat !== 0) {
            obj.heartbeat = Math.round(message.heartbeat);
        }
        if (message.lenses) {
            const entries = Object.entries(message.lenses);
            if (entries.length > 0) {
                obj.lenses = {};
                entries.forEach(([k, v]) => {
                    obj.lenses[k] = base64FromBytes(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return PushLensSubscriptionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse();
        message.lens = (object.lens !== undefined && object.lens !== null) ? Lens.fromPartial(object.lens) : undefined;
        message.excludedLens = (object.excludedLens !== undefined && object.excludedLens !== null)
            ? PushLensSubscriptionResponse_ExcludedLens.fromPartial(object.excludedLens)
            : undefined;
        message.heartbeat = object.heartbeat ?? 0;
        message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBasePushLensSubscriptionResponse_LensesEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const PushLensSubscriptionResponse_LensesEntry = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse_LensesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return PushLensSubscriptionResponse_LensesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse_LensesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBasePushLensSubscriptionResponse_ExcludedLens() {
    return { lensId: "0", code: PushLensSubscriptionResponse_ExcludedLens_Code.UNSET };
}
export const PushLensSubscriptionResponse_ExcludedLens = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse_ExcludedLens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.lensId = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.code = pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(reader.int32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            lensId: isSet(object.lensId) ? globalThis.String(object.lensId) : "0",
            code: isSet(object.code)
                ? pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(object.code)
                : PushLensSubscriptionResponse_ExcludedLens_Code.UNSET,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.lensId !== "0") {
            obj.lensId = message.lensId;
        }
        if (message.code !== PushLensSubscriptionResponse_ExcludedLens_Code.UNSET) {
            obj.code = pushLensSubscriptionResponse_ExcludedLens_CodeToJSON(message.code);
        }
        return obj;
    },
    create(base) {
        return PushLensSubscriptionResponse_ExcludedLens.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse_ExcludedLens();
        message.lensId = object.lensId ?? "0";
        message.code = object.code ?? PushLensSubscriptionResponse_ExcludedLens_Code.UNSET;
        return message;
    },
};
function createBaseListenLensPushRequest() {
    return { extensionRequestContext: new Uint8Array(0), heartbeat: 0 };
}
export const ListenLensPushRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.extensionRequestContext.length !== 0) {
            writer.uint32(18).bytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            writer.uint32(24).int32(message.heartbeat);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.extensionRequestContext = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.heartbeat = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            extensionRequestContext: isSet(object.extensionRequestContext)
                ? bytesFromBase64(object.extensionRequestContext)
                : new Uint8Array(0),
            heartbeat: isSet(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.extensionRequestContext.length !== 0) {
            obj.extensionRequestContext = base64FromBytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            obj.heartbeat = Math.round(message.heartbeat);
        }
        return obj;
    },
    create(base) {
        return ListenLensPushRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListenLensPushRequest();
        message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array(0);
        message.heartbeat = object.heartbeat ?? 0;
        return message;
    },
};
function createBaseListenLensPushResponse() {
    return { excludedLens: undefined, heartbeat: 0, lenses: {} };
}
export const ListenLensPushResponse = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.excludedLens = ListenLensPushResponse_ExcludedLens.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.heartbeat = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = ListenLensPushResponse_LensesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.lenses[entry4.key] = entry4.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            excludedLens: isSet(object.excludedLens)
                ? ListenLensPushResponse_ExcludedLens.fromJSON(object.excludedLens)
                : undefined,
            heartbeat: isSet(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
            lenses: isObject(object.lenses)
                ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.excludedLens !== undefined) {
            obj.excludedLens = ListenLensPushResponse_ExcludedLens.toJSON(message.excludedLens);
        }
        if (message.heartbeat !== 0) {
            obj.heartbeat = Math.round(message.heartbeat);
        }
        if (message.lenses) {
            const entries = Object.entries(message.lenses);
            if (entries.length > 0) {
                obj.lenses = {};
                entries.forEach(([k, v]) => {
                    obj.lenses[k] = base64FromBytes(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ListenLensPushResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse();
        message.excludedLens = (object.excludedLens !== undefined && object.excludedLens !== null)
            ? ListenLensPushResponse_ExcludedLens.fromPartial(object.excludedLens)
            : undefined;
        message.heartbeat = object.heartbeat ?? 0;
        message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseListenLensPushResponse_LensesEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const ListenLensPushResponse_LensesEntry = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse_LensesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return ListenLensPushResponse_LensesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse_LensesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseListenLensPushResponse_ExcludedLens() {
    return { lensId: "0", code: ListenLensPushResponse_ExcludedLens_Code.UNSET };
}
export const ListenLensPushResponse_ExcludedLens = {
    encode() {
        throw new Error("Not implemented.");
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse_ExcludedLens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.lensId = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.code = listenLensPushResponse_ExcludedLens_CodeFromJSON(reader.int32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            lensId: isSet(object.lensId) ? globalThis.String(object.lensId) : "0",
            code: isSet(object.code)
                ? listenLensPushResponse_ExcludedLens_CodeFromJSON(object.code)
                : ListenLensPushResponse_ExcludedLens_Code.UNSET,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.lensId !== "0") {
            obj.lensId = message.lensId;
        }
        if (message.code !== ListenLensPushResponse_ExcludedLens_Code.UNSET) {
            obj.code = listenLensPushResponse_ExcludedLens_CodeToJSON(message.code);
        }
        return obj;
    },
    create(base) {
        return ListenLensPushResponse_ExcludedLens.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse_ExcludedLens();
        message.lensId = object.lensId ?? "0";
        message.code = object.code ?? ListenLensPushResponse_ExcludedLens_Code.UNSET;
        return message;
    },
};
export class PushToDeviceClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.PushLensSubscription = this.PushLensSubscription.bind(this);
        this.ListenLensPush = this.ListenLensPush.bind(this);
    }
    PushLensSubscription(request, metadata) {
        throw new Error("ts-proto does not yet support client streaming!");
    }
    ListenLensPush(request, metadata) {
        return this.rpc.invoke(PushToDeviceListenLensPushDesc, ListenLensPushRequest.fromPartial(request), metadata);
    }
}
export const PushToDeviceDesc = { serviceName: "com.snap.camerakit.v3.PushToDevice" };
export const PushToDeviceListenLensPushDesc = {
    methodName: "ListenLensPush",
    service: PushToDeviceDesc,
    requestStream: false,
    responseStream: true,
    requestType: {
        serializeBinary() {
            return ListenLensPushRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ListenLensPushResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
export class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
    invoke(methodDesc, _request, metadata) {
        const upStreamCodes = this.options.upStreamRetryCodes ?? [];
        const DEFAULT_TIMEOUT_TIME = 3000;
        const request = { ..._request, ...methodDesc.requestType };
        const transport = this.options.streamingTransport ?? this.options.transport;
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Observable((observer) => {
            const upStream = () => {
                const client = grpc.invoke(methodDesc, {
                    host: this.host,
                    request,
                    ...(transport !== undefined ? { transport } : {}),
                    metadata: maybeCombinedMetadata ?? {},
                    debug: this.options.debug ?? false,
                    onMessage: (next) => observer.next(next),
                    onEnd: (code, message, trailers) => {
                        if (code === 0) {
                            observer.complete();
                        }
                        else if (upStreamCodes.includes(code)) {
                            setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
                        }
                        else {
                            const err = new Error(message);
                            err.code = code;
                            err.metadata = trailers;
                            observer.error(err);
                        }
                    },
                });
                observer.add(() => client.close());
            };
            upStream();
        }).pipe(share());
    }
}
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
export class GrpcWebError extends globalThis.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
